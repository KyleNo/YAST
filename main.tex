\documentclass[oneside]{book}
\usepackage[margin=1.2in]{geometry}
\usepackage[cache=false]{minted}
\usepackage{tikz}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{amssymb}
\usepackage{ifthen}
\usepackage[most, minted, skins]{tcolorbox}
\tcbuselibrary{many}

\usepackage{a4wide}
\usepackage{array}
\newcolumntype{C}{>{\centering\arraybackslash}X}
\renewcommand{\arraystretch}{1.2}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{caption}
\usepackage{array}
\usepackage{float}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{blindtext}
\usepackage{tocloft}

\usepackage[hidelinks,
    colorlinks = true,
    linkcolor = blue,
    urlcolor  = blue,
    citecolor = black,
    anchorcolor = black]{hyperref}
\usepackage{vhistory}

% \immediate\write18{which pygmentize > pygmentize-path.txt}
% \pagecolor{gray}
% \color{white}
\definecolor{bgdark}{HTML}{2E3440}  % Nord-ish dark gray-blue
\definecolor{fgtext}{HTML}{ECEFF4} % Near-white
\definecolor{arrowcolor}{HTML}{88C0D0}
\definecolor{darkline}{HTML}{4C566A}

\definecolor{codebg}{HTML}{2E3440}
\definecolor{codelinebg}{HTML}{3B4252}
\definecolor{codelinefg}{HTML}{88C0D0}
\definecolor{codefg}{HTML}{ECEFF4}
\definecolor{arrowdark}{HTML}{88C0D0}
\definecolor{arrowlight}{HTML}{333333}
\definecolor{bglight}{HTML}{FAFAFA}
\definecolor{bgdark}{HTML}{242424}
\definecolor{linenobgdark}{HTML}{2A2D2E}
\definecolor{borderdark}{HTML}{2A2D2E}



\newboolean{darkmodeon}
\setboolean{darkmodeon}{true}   % <-- set to false for light mode

\ifthenelse{\boolean{darkmodeon}}
% Dark Mode
{\newtcblisting{msccode}{
  minted language=msc2,
  minted style=msc_dark,
  minted options={
      fontsize=\normalsize,
      linenos,
      numbersep=1mm,
      breaksymbolleft=\textcolor{arrowdark}{\tiny$\hookrightarrow$},
      breaklines=true,
  },% <-- put other minted options inside the brackets
  overlay={%
      \begin{tcbclipinterior}
          \fill[linenobgdark] (frame.south west) rectangle ([xshift=5mm]frame.north west);
      \end{tcbclipinterior}
  },
  colback=bgdark,
  colframe=borderdark,
  before skip=5pt plus 2pt,
  breakable,
  enhanced,% <-- put other tcolorbox options here
  listing only
  }}
% Light Mode
{\newtcblisting{msccode}{
  minted language=msc2,
  minted style=msc_light,
  minted options={
      fontsize=\normalsize,
      linenos,
      numbersep=1mm,
      breaksymbolleft=\textcolor{arrowlight}{\tiny$\hookrightarrow$},
      breaklines=true,
  },% <-- put other minted options inside the brackets
  overlay={%
      \begin{tcbclipinterior}
          \fill[gray!25] (frame.south west) rectangle ([xshift=5mm]frame.north west);
      \end{tcbclipinterior}
  },
  colback=bglight,
  colframe=black!70,
  before skip=5pt plus 2pt,
  breakable,
  enhanced,% <-- put other tcolorbox options here
  listing only
  }}

\ifthenelse{\boolean{darkmodeon}}
  % Dark Mode
  {\newtcblisting{nmscode}{
    minted language=nms,
    minted style=msc_dark,
    minted options={
        fontsize=\normalsize,
        linenos,
        numbersep=1mm,
        breaksymbolleft=\textcolor{arrowdark}{\tiny$\hookrightarrow$},
        breaklines=true,
    },% <-- put other minted options inside the brackets
    overlay={%
        \begin{tcbclipinterior}
            \fill[linenobgdark] (frame.south west) rectangle ([xshift=5mm]frame.north west);
        \end{tcbclipinterior}
    },
    colback=bgdark,
    colframe=borderdark,
    before skip=5pt plus 2pt,
    breakable,
    enhanced,% <-- put other tcolorbox options here
    listing only
    }}
  % Light Mode
  {\newtcblisting{nmscode}{
    minted language=nms,
    minted style=msc_light,
    minted options={
        fontsize=\normalsize,
        linenos,
        numbersep=1mm,
        breaksymbolleft=\textcolor{arrowlight}{\tiny$\hookrightarrow$},
        breaklines=true,
    },% <-- put other minted options inside the brackets
    overlay={%
        \begin{tcbclipinterior}
            \fill[gray!25] (frame.south west) rectangle ([xshift=5mm]frame.north west);
        \end{tcbclipinterior}
    },
    colback=bglight,
    colframe=black!70,
    before skip=5pt plus 2pt,
    breakable,
    enhanced,% <-- put other tcolorbox options here
    listing only
}}

% \renewcommand{\theFancyVerbLine}{\ttfamily
%   \textcolor[rgb]{0,0,0}{\small{\arabic{FancyVerbLine}}}}

\ifthenelse{\boolean{darkmodeon}}
{\renewcommand{\theFancyVerbLine}{\ttfamily
\textcolor[HTML]{707880}{\small{\arabic{FancyVerbLine}}}}}
{\renewcommand{\theFancyVerbLine}{\ttfamily
\textcolor[rgb]{0,0,0}{\small{\arabic{FancyVerbLine}}}}}

%%% Text Boxes

\newtcolorbox{satbox}[2][]{%
  enhanced,colback=white,colframe=black,coltitle=black,
  sharp corners,boxrule=0.4pt,
  fonttitle=\itshape,
  attach boxed title to top left={yshift=-0.3\baselineskip-0.4pt,xshift=2mm},
  boxed title style={tile,size=minimal,left=0.5mm,right=0.5mm,
    colback=white,before upper=\strut},
  title=#2,#1
}

\tcbset{
    enhanced,
    drop shadow,
    attach boxed title to top left={
        xshift=0.5cm,
        yshift=-\tcboxedtitleheight/2},  % <---
    top=4mm,
    coltitle=black,
    colbacktitle=gray!35!green!10,
    beforeafter skip=\baselineskip,
}
\newenvironment{thinkbox}{%
    \begin{tcolorbox}[title=Stop and Think]%
    }{
    \end{tcolorbox}
    }


%%% Preface environment
% ===== Define abstract environment =====
\newcommand{\prefacename}{Preface}
\newenvironment{preface}{
    \vspace*{\stretch{2}}
    {\noindent \bfseries \Huge \prefacename}
    \begin{center}
        \phantomsection \addcontentsline{toc}{chapter}{\prefacename} % enable this if you want to put the preface in the table of contents
        \thispagestyle{plain}
    \end{center}%
}
{\vspace*{\stretch{5}}}

%%%%% END OF PREAMBLE %%%%%

\begin{document}

\pagestyle{empty}

\title{Yet Another Scripting Tetorial \\
        \large For Minr Scripts 2.4.7}
\author{Tetration}
\date{\vhCurrentDate \\Version \vhCurrentVersion}
\maketitle

% \shipout\null

\frontmatter
\pagenumbering{roman} 

\begin{preface}
\section*{Why is This a Thing?}
Minr Scripts (MSC) is a uniquely powerful tool for map makers to bring their creations to life. The capabilities for adding interactivity to maps is unmatched across public servers (don't fact check this). Minr is a niche community which allows for user-created scripts to be manually checked by admins. This enables the potency of MSC to be accessible to Greens+.

MSC is something many people find intimidating. Some people think you need a computer science degree or 100s of hours of programming experience to conquer MSC. Some people just don't know where to start. I want MSC to be as accessible as possible to the Greenie community. Of course, there are MSC tutorials scattered around the Minr resource ecosystem. Most are guides on using specific features.

On the forums, only the \href{https://forums.minr.org/threads/scripts-with-rman-1-basic-script-understanding.3193/}{"Scripts with rman!"} series is designed to be used by people who are complete beginners. This is an effective tutorial series for getting started quickly, but there is a lot of foundational information that I think should be built up to truly master MSC. It can also be annoying to navigate between each installment in the series, since they are located in separate forum posts.

Another notable scripting tutorial that exists is the in the \href{https://msc-documentation.readthedocs.io/en/latest/tutorial.html}{documentation}. This tutorial is a bit more comprehensive, but its presentation is a little overwhelming. It also lacks interactivity; there are very few examples of scripts that are interesting enough for a learner to be motivated to try and run on their own. The examples that exist are somewhat contrived and don't particularly encourage the reader to think about what might be possible with scripts or the challenges of implementation.

The goal of this Tetorial, is to unify many disparate chunks of knowledge into a single guide. The guide should be comprehensive in scope, encourage deep thought about scripts and their potential applications, and foster the skills needed to allow MSC to extend your creative capabilities. I also want to provide some guidance on optimizing your scripting environment and how to write readable, maintainable scripts. The latter of which is an oft neglected subject, even among some of the best scripters on Minr. A lot of effort has also gone toward increasing the readability of this guide, especially the blocks of code.

\section*{Who is This For?}
This guide is not for everyone and I understand that. Not everyone has the time or energy to commit to mastering a skill. If all you ever want to do is write simple scripts that print messages for the player and prompt responses, I encourage you to seek one of the sources I linked in the previous section.

However, if you are interested in building a solid foundation of MSC knowledge and creating new and unique experiences through the power of MSC, I implore you to stick around and try to put in the work needed to build your skills. You may be surprised how approachable scripting can be.

You do \textbf{NOT} need to have any prior programming knowledge for this guide. You do \textbf{NOT} need to have any inbuilt proclivities for technical subjects. You will, however, need to build a technical mindset to apply towards scripting. This is not something that comes easily for anyone. It is built up through practice and rigor. Hopefully, this guide allow you to cultivate this mindset through thought-provoking questions and exercises. You will need to be patient. Some things may be confusing or hard to understand. You cannot expect to conquer every obstacle instantly. I guess I should also mention that you should be Green+ for this to be of any use to you. If you're somehow reading this and you're not Green+, go beat HC.

None of this is meant to be intimidating; I just want to set realistic expectations. If you actually read prefaces and have read up to this point, that is a sign that you will be successful in learning from this Tetorial. It shows you are passionate enough about expanding your creative expressibility to slog through a verbose preamble.

\section*{What Will This Cover?}
This Tetorial will start with the environment setup. This is something that every tutorial omits (besides \href{https://forums.minr.org/threads/visual-studio-code-extension-for-minr-scripts.6175/}{Lightwood13's post}). This is something that I think is very important. If you're environment is an impedence, you may become frustrated and give up. The habits that you form when you first learn something can be hard to break, and building habits in a quick-and-easy environment may cause pain and suffering in the future.

In the next chapter, we dive into the basics scripts, contextualizing them within Minecraft and Minr. We will cover fundamental aspects of the language in a way that people who have never programmed before will understand. This chapter will prepare you to create basic scripts that players can interact with in chat.

The chapter after that will cover the remaining important topics. This will prepare you to make scripts with logic that depend on answers given by players and the current state of the world. It will also introduce functions which will allow you to simplify your scripts by eliminating redundant code. After this, you should be able to do about 95\% of scripting tasks that you would normally need for a Minr map.

The Advanced Topics chapter contains some very useful features. It also covers Built-ins, some of which are necessary for interacting with or querying things in Minecraft. The rest of this chapter is about optimizing and organizing scripts, as well as best practices for readability and maintability. This chapter should also help you fill in gaps in your knowledge. You should be very competent in MSC after reading up to this point.

The Special Topics chapter will cover a variety of somewhat obscure features. Many of these are specific to Minecraft mechanics. Some are focused on general computer science topics. You don't need to read this chapter unless you want to use one of the features or you just want to be very proficient and knowledgeable about MSC.

The last chapter is a few different recipes for scripting tasks that are commonly needed in Minr maps. Reading through these may give you inspiration for solving related problems or organizing scripting projects.

With all that said, I hope this Tetorial will help you build a foundation for mastering MSC. If you have any feedback or questions related to this guide, feel free to reach out to me. Good luck!

\end{preface}

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=blue}

\mainmatter
\pagestyle{plain}

\chapter{Environment}
Before we can start scripting, we need to discuss the environment. By "environment," I mean the things that scripts are embedded in, the things that scripts affect and interfaces which you will write, save, and export scripts in. This is an important topic to get through. I do not recommend skipping this chapter.

\section{Welcome to the Test Server!}
The test server is for Green+ player only. If you are reading this and are not Green+, go beat HC and come back. The server allows you to test out things that can only be done by staff on the main server. The most common things you might want to test are scripts, world edit commands, and various Vanilla Minecraft commands. The Test Server is the quintessential scripting tool. You need to test your scripts to make sure that they are importable and work correctly. To join the Test Server, go to \href{https://forums.minr.org/pages/testserver/}{this forum page}. Familiarize yourself with the rules and follow the instructions to become whitelisted and op'ed.

\subsection{Command Syntax}

We will briefly cover commands. Some commands will be Vanilla, some will be for common plugins, and some will be for the Minr plugin. When discussing commands, you will often see syntax like:

\begin{verbatim}
/advancement (grant|revoke) <targets> only <advancement> [<criterion>]
\end{verbatim}

This syntax might seem overwhelming, but it's actually fairly straightforward. The first word in a command (which follows the \texttt{/}) is the command name. Everything that follow the command name is an argument. Arguments that aren't enclosed by brackets (often called decorators in this context) like \texttt{only} in the above example are written in the command directly. Arguments enclosed in angle brackets like \texttt{<targets>} are required arguments. When you write the command, you must subtitute this with an expression that represents that argument type. Arguments enclosed in square brackets indicate that they are optional. In this example, \texttt{[<criterion>]} is optional, but the angled brackets indicate that criterion should be substituted rather than written directly. The pipe character represents a choice. In the example, \texttt{grant|revoke} means you should either write \texttt{grant} or \texttt{revoke} for that argument of the command. The parenthesis around them are just there to indicate that they are grouped as an argument. 

This paragraph is included for completeness and isn't necessary for you to understand completely. You may see ellipses (\texttt{...}) in command syntaxes. These should mean that a full command or subcommand should replace the ellipses, but sometimes people will use ellipses to just mean "something goes here." Finally, there is also a notation that is only used for \texttt{execute} commands. It looks like \texttt{... align <axes> -> execute}. This just means that another execute command needs to be chained after the command.

There is also some nuance with argument types that you don't need to understand for now, but the most important thing to note is that arguments can contain spaces. In the command below, the argument \texttt{<location>} has type \texttt{vec3} (three numbers separated by spaces).

\begin{verbatim}
/teleport <targets> <location> <rotation>
\end{verbatim}

A valid argument of this type could be \texttt{1 2 3}. The argument \texttt{<rotation>} is basically two numbers like \texttt{30 45}. So the command could end with \texttt{1 2 3 30 45}. This can be confusing to parse, but you will get used to it as you work with commands.

One final thing to note about command syntax is that if a command contains multiple optional arguments, you cannot pick which arguments to use freely (at least for Vanilla commands). You must include all optional arguments to the left of each argument that you include. Effectively, this means that as soon as you choose not to include an optional argument when writing a command, you may not add any more arguments. A command with syntax \texttt{/a [b] [c] [d]} only has valid calls of \texttt{/a}, \texttt{/a b}, \mbox{\texttt{/a b c}}, and \texttt{/a b c d}.


\begin{thinkbox}
    \begin{enumerate}
        \item Why do we need parentheses to group argument choices? Why can't we just do the following?
        \begin{verbatim}
/advancement grant|revoke <targets> only <advancement> [<criterion>]\end{verbatim} 
        If you need a hint, consider item (c) in question 2.
        \item Try to understand the following command syntaxes. For each argument, determine whether it is required, determine whether it should be written directly or substituted, and guess what might be valid values.
        \begin{enumerate}
            \item \texttt{/kick <targets> [<reason>]}
            \item \texttt{/setblock <pos> <block> [destroy|keep|replace|strict]}
            \item \texttt{/execute rotated (<rot>|as <targets>) -> execute}
            \item \texttt{/effect give <targets> <effect> infinite [<amplifier>]} \\
            \texttt{[<hideParticles>]}
        \end{enumerate}
        \item Why don't we see Vanilla command syntaxes with required arguments to the right of optional arguments?
    \end{enumerate}
\end{thinkbox}

\subsection{Basic Commands}

At this point, you should have access to the Test Server and be somewhat comfortable reading command syntax. In this section we will introduce commands that you will need to set up a testing area and commands that are used often in scripts.

\subsubsection*{Changing Gamemodes}

The first thing you will want to do is go into creative and spectator modes. You can always use the Vanilla command \texttt{/gamemode <gamemode> [<target>]}, but it's more convenient to use the shortcuts \texttt{/creative}, \texttt{/spectator}, etc. for changing your own gamemode. Even more convenient is the \texttt{F3+F4} keyboard shortcut. Go ahead and fly somewhere away from other people's stuff and find a nice place to set up a testing area.

\subsubsection*{Building a platform}

It is usually very convenient to have a flat platform to test scripts on. The easiest way to get this platform is with WorldEdit. Simply fly to one corner of where you want the platform to be and run \texttt{//pos1}, then fly to the opposite corner and run \texttt{//pos2}, and set the selection to a block of your choosing with \texttt{//set <pattern>} where \texttt{<pattern>} can be a block of your choosing (please do not choose something with gravity like sand or water or block entities like furnaces or beehives). A $100 \times 100$ platform should be enough for a long time. This is about all the world edit we'll cover in this guide. If you want to learn more there are many resources. % maybe link some in an appendix

\subsubsection*{Defining a region}

While you have this area selected, you may as well create a region. Run \texttt{//expand vert} to make the selection cover every y level. Then do \texttt{/rg define <id> [<owners>]}, where \texttt{<id>} is the name of the region and \texttt{<owners>} are the players you wish to be the owners of the region (you should include yourself). The region will be defined based on your current WorldEdit selection. This won't be too helpful in preventing people from messing with your region since ops bypass region protection by default on the Test Server, but it is good to know how to define a region and there may be flags you want to set.

\subsubsection*{Teleporting}

One of the most useful commands in scripting is \texttt{/teleport}, which has the alias \texttt{/tp}. Teleporting the player has obviously useful applications in making maps including story telling, maze design, and de-cheesing doors. You may already be familiar with Vanilla \texttt{tp} commands. If not here are all of the valid forms:

\begin{verbatim}
/minecraft:tp <destination_entity>
/minecraft:tp <targets> <destination_entity>
/minecraft:tp <location>
/minecraft:tp <targets> <location>
/minecraft:tp <targets> <location> <rotation>
/minecraft:tp <targets> <location> facing <facingLocation>
/minecraft:tp <targets> <location> facing entity <facingEntity> [<facingAnchor>]
\end{verbatim}

You might notice that I prefixed all the \texttt{tp} command syntaxes with \texttt{minecraft:}. This specifies that the Vanilla version of the command should be used. By default \texttt{tp} will try to use the Minr-specific command whose syntaxes are listed below. The Vanilla version is a bit more powerful than Minr's. It let's you select multiple targets that don't have to be players, and you can have the player face a position or entity. \texttt{minr:tp} on the other hand let's you specify a world to tp to. The most relevant distinction between these two is that \texttt{minecraft:tp} won't show up in chat when called through a script.

\begin{verbatim}
/minr:tp <player> [<player-destination>|<position>]
/minr:tp <position> [<world>|<rotation>]
\end{verbatim}

\subsubsection*{Potion Effects}
Another important command that will be useful for scripting is \texttt{/effect}. These allow you to give and remove arbitrary potion effect to and from entities. Here are the command syntaxes:

\begin{verbatim}
/effect give <targets> <effect> [<seconds>|infinite] [<amplifier>]
[<hideParticles>]
/effect clear [<targets>] [<effect>]
\end{verbatim}

\subsubsection*{Giving Items}
Giving players items is a very useful task in scripting. Specifying the metadata of items (custom name, lore, modifiers, etc.) can be tricky, but there are tools that can help you which we will cover shortly. The complementary task of giving items is clearing them. Both command's syntaxes are shown below.

\begin{verbatim}
/give <targets> <item> [<count>]
/clear [<targets>] [<item>] [<maxCount>]
\end{verbatim}

\subsubsection*{Summoning Entities}
On occasion, you may want to summon specific entities. The syntax is show below. Again, summoning entities with specific attributes is very difficult. We will discuss tools for doing this soon.

\begin{verbatim}
/summon <entity> [<pos>] [<nbt>]
\end{verbatim}

\subsubsection*{Killing Players and Entities}
Killing the player who is running the script is easy. Simply run \texttt{/kill}. Again, there is a Minr-specific \texttt{kill} command that is used by default. If you want to kill things other than your own player, you need to use the Vanilla version. This is something you want to be \textbf{VERY} careful about. It's generally safe if you have a specific player you want to kill, but any other entity has to be targetted with target selectors which can be extremely dangerous. If your target selector is \texttt{@e} without any additional arguments, for example, you will target every single loaded entity on the server. Combining this with the \texttt{kill} command will have devastating effects on the server. \textbf{NEVER RUN COMMANDS WITH @e or @a WITHOUT ARGUMENTS!} I will acknowledge that it is sometimes necessary to kill non-player entities or specific groups of players, so I will explain how to use target selectors in the following section. For now, note the \texttt{kill} command syntax.

\begin{verbatim}
/minecraft:kill [<targets>]
\end{verbatim}

\subsubsection*{Target Selectors}

The simplest target selector is \texttt{@s}. This will select the entity that executed the command. If you run a command normally, this will be your player. The next simplest selector is \texttt{@p}. This will select the player nearest to the location that the command was executed at. If you run a command normally, this will be your player. The target selector \texttt{@n} selects the nearest entity. Next is \texttt{@a}. This will select all players on the server. Clearly this is dangerous on its own. Finally, there is \texttt{@e}. This will select all entities in loaded chunks on the server. This is extremely dangerous. Exercise extreme caution.

The arguments to these selectors are key to ensuring you affect only the entities that you want to affect. Arguments are written as a list of argument names and values enclosed by square brackets. The syntax can be described as follows. \texttt{variable} can be \texttt{e}, \texttt{a}, \texttt{p}, etc. Note that here the square brackets are actually typed in the expression and the ellipsis represents extending the list of argument-value pairs rather than a full command/subcommand.

\begin{verbatim}
@<variable>[<argument>=<value>,<argument>=<value>,...]
\end{verbatim}

There are many arguments, but I will cover some of the more useful ones. The most important one is \texttt{distance}. You should \textbf{ALWAYS} include a spatial argument if you are using \texttt{@e} or \texttt{@a}. \texttt{distance} is the simplest spatial argument. You will almost always use it like \texttt{distance=..10}. This limits the entities being targetted to be at most 10 blocks away. You can replace this number with whatever is appropriate for you use case. Just be careful.

Another useful argument is \texttt{type}. You can choose to only target pigs for example with \texttt{type=pig}. You can also choose to target all entities that aren't players with \texttt{type=!player}.

You can add an extra layer of safety by utilizing tags. Usually if there are things you want to kill, they are things that you have summoned earlier. If this is the case, you can give the entities a unique tag when you summon them and only select that tag when you kill it with \texttt{tag=<tagname>}.

Another layer of safety is to use the \texttt{limit} and \texttt{sort} arguments to cap the number of entities selected. This could be \texttt{limit=5,sort=nearest} to only select up to 5 entities and choose the 5 nearest entities which match the other arguments.

There are many more arguments that you can read about \href{https://minecraft.wiki/w/Target_selectors}{on the wiki}. The most important takeaway is to use something like \texttt{distance=..10} whenever you target all entities or players. If you are ever unsure about a command, ask someone who is knowledgeable or test it in a singleplayer world or in your own personal server.

\subsubsection*{Commands with Metadata}
As mentioned before, it challenging to write some commands, especially those which give certain attributes to items or entities. Creating such commands requires writing a complicated syntax tree inline, which is unintuitive even for experienced professional programmers. Luckily, there's a tool called \href{https://mcstacker.net/}{MCStacker.net}. This will be your best friend when writing these commands. Be mindful that there is a 256 character limit per chat message (which includes commands), so you can't run super long commands in chat. You will need to use a command block or run it in a script (we'll talk about scripts at some point I promise).

\subsection{Script Commands}

\section{Hastebin}
\blindtext

\section{Visual Studio Code}
\blindtext

\section{Source Control}
\blindtext

\section{Tips}
\blindtext

\section{Summary}
\blindtext

\chapter{The Basics}

\section{Triggers}
\blindtext

\section{What is a Script?}
\blindtext

\section{Running Commands}
\blindtext

\section{Printing to the Player}
\blindtext

\section{Delay}
\blindtext

\section{Values and Types}
\blindtext

\section{Expressions}
\blindtext

\section{Variables}
\blindtext

\section{Summary}
\blindtext

\section{Exercises}
\blindtext

\chapter{Core Topics}
\blindtext

\section{Lists}

\section{Control Flow}
\blindtext

\section{Namespaces}
\blindtext

\section{Variable Qualifiers}
\blindtext

\section{Functions}
\blindtext

\section{Meta Operators}
\blindtext

\section{Summary}
\blindtext

\section{Exercises}
\blindtext

\chapter{Advanced Topics}
\blindtext

\section{User-Defined Types}
\blindtext

\section{Schematics}
\blindtext

\section{Chat Scripts}
\blindtext

\section{More about Lists and Strings}
\blindtext

\section{Built-in Namespaces}
\blindtext

\section{Built-in Types}
\blindtext

\section{Complexity}
\blindtext

\section{Best Practices}
\blindtext

\section{Learn to Learn}
\blindtext

\section{Summary}
\blindtext

\section{Exercises}
\blindtext

\chapter{Special Topics}
\blindtext

\section{Block Displays}
\blindtext

\section{Animating Entities}
\blindtext

\section{Abstraction}
\blindtext

\section{Books}
\blindtext

\section{Scoreboards}
\blindtext

\section{Boss Bars}
\blindtext

\section{Importing Scripts with Scripts}
\blindtext

\section{Execute}
\blindtext

\section{Resource Packs}
\blindtext

\section{Debug Tools}
\blindtext

\section{Recursion}
\blindtext

\section{Attributes}
\blindtext

\section{Summary}
\blindtext

\section{Exercises}
\blindtext

\chapter{Recipes}

\section{Stateful Puzzles}
\blindtext

\section{Search Maps}
\blindtext

\section{Managing Heads}
\blindtext


% \begin{msccode}
% # Long prng::uuidToSeed(String uuid, Long modulo)

% @using prng
% @player Hello? test

% @define Long seed = 0l

% @define Boolean boo3 = true

% @var myNamespace::myObj.myMethod(0, 2, 3)

% @var myNamespace::myFunction("test")

% @var seed = normalize(seed).toLowerCase().length()

% @define String hex = "0123456789abcdef"
% @define String test_string = "seed is {{seed}}"
% @define Int j = 0

% @var uuid = uuid.replace("-", "").toLowerCase()
% @define Int l = uuid.length()-9

% @for Int i in list::range(0,l)
%     @player loop iteration {{i}}
%     @var j = l-i-1
%     @var seed = (seed + hex.indexOf(uuid.substring(j, j+1)) * pow(16l, i)) % modulo
% @done

% @define Box box = Box()

% @return seed
% \end{msccode}

% \begin{nmscode}
% @namespace myNamespace
% 	# myFunc documentation
% 	Double myFunc(Player player, Item item)
% 	myVoidFunc()
% 	# myVar documentation
% 	Double myVar

% 	# myClass documentation
% 	@class MyClass
% 		# constructor
% 		MyClass(Double value)
% 		# another constructor
% 		MyClass(Double value1, Double value2)
% 		# field
% 		Double x
% 		# getter
% 		Double getX()
% 		# setter
% 		setX(Double newValue)
% 		myNamespace::MyClass getMyClass()
% 	@endclass
% @endnamespace
% \end{nmscode}

\begin{versionhistory}
    \vhEntry{1.0}{\today}{Tetration}{First Publication}
\end{versionhistory}

\end{document}
