\documentclass[oneside]{book}

\input{preamble.tex}

\begin{document}

\pagestyle{empty}

\title{Yet Another Scripting Tetorial \\
        \large For Minr Scripts 2.4.7}
\author{Tetration}
\date{\vhCurrentDate \\Version \vhCurrentVersion}
\maketitle

% \shipout\null

\frontmatter
\pagenumbering{roman} 

\begin{preface}
\section*{Why is This a Thing?}
Minr Scripts (MSC) is a uniquely powerful tool for map makers to bring their creations to life. The capabilities for adding interactivity to maps is unmatched across public servers (don't fact check this). Minr is a niche community which allows for user-created scripts to be manually checked by admins. This enables the potency of MSC to be accessible to Greens+.

MSC is something many people find intimidating. Some people think you need a computer science degree or 100s of hours of programming experience to conquer MSC. Some people just don't know where to start. I want MSC to be as accessible as possible to the Greenie community. Of course, there are MSC tutorials scattered around the Minr resource ecosystem. Most are guides on using specific features, but a couple are made for beginners.

On the forums, only the \href{https://forums.minr.org/threads/scripts-with-rman-1-basic-script-understanding.3193/}{"Scripts with rman!"} series is designed to be used by people who are complete beginners. This is an effective tutorial series for getting started quickly, but there is a lot of foundational information that I think should be built up to truly master MSC. It can also be annoying to navigate between each installment in the series, since they are located in separate forum posts.

Another notable scripting tutorial that exists is the in the \href{https://msc-documentation.readthedocs.io/en/latest/tutorial.html}{documentation}. This tutorial is a bit more comprehensive, but its presentation is a little overwhelming. It also lacks interactivity; there are very few examples of scripts that are interesting enough for a learner to be motivated to try and run on their own. The examples that exist are somewhat contrived and don't particularly encourage the reader to think about what might be possible with scripts or the challenges of implementation.

The goal of this Tetorial, is to unify many disparate chunks of knowledge into a single guide. The guide should be comprehensive in scope, encourage deep thought about scripts and their potential applications, and foster the skills needed to allow MSC to extend your creative capabilities. I also want to provide some guidance on optimizing your scripting environment and how to write readable, maintainable scripts. The latter of which is an oft neglected subject, even among some of the best scripters on Minr. A lot of effort has also gone toward increasing the readability of this guide, especially the blocks of code. Feel free to reach out if you have any suggestions.

\section*{Who is This For?}
This guide is not for everyone and I understand that. Not everyone has the time or energy to commit to mastering a skill. If all you ever want to do is write simple scripts that print messages for the player and prompt responses, I encourage you to seek one of the sources I linked in the previous section.

However, if you are interested in building a solid foundation of MSC knowledge and creating new and unique experiences through the power of MSC, I implore you to stick around and try to put in the work needed to build your skills. You may be surprised how approachable scripting can be.

You do \textbf{NOT} need to have any prior programming knowledge for this guide. You do \textbf{NOT} need to have any inbuilt proclivities for technical subjects. You will, however, need to build a technical mindset to apply towards scripting. This is not something that comes easily for anyone. It is built up through practice and rigor. Hopefully, this guide allow you to cultivate this mindset through thought-provoking questions and exercises. You will need to be patient. Some things may be confusing or hard to understand. You cannot expect to conquer every obstacle instantly. I guess I should also mention that you should be Green+ for this to be of any use to you. If you're somehow reading this and you're not Green+, go beat HC.

None of this is meant to be intimidating; I just want to set realistic expectations. If you actually read prefaces and have read up to this point, that is a sign that you will be successful in learning from this Tetorial. It shows you are passionate enough about expanding your creative expressibility to slog through a verbose preamble.

\section*{What Will This Cover?}
This Tetorial will start with the environment setup. This is something that every tutorial omits or glosses over (besides \href{https://forums.minr.org/threads/visual-studio-code-extension-for-minr-scripts.6175/}{Lightwood13's post}). This is something that I think is very important. If you're environment is an impedence, you may become frustrated and give up. The habits that you form when you first learn something can be hard to break, and building habits in a quick-and-easy environment may cause pain and suffering in the future.

In the next chapter, we dive into the basics scripts, contextualizing them within Minecraft and Minr. We will cover fundamental aspects of the language in a way that people who have never programmed before will understand. This chapter will prepare you to create basic scripts that players can interact with in chat.

The chapter after that will cover the remaining important topics. This will prepare you to make scripts with logic that depend on answers given by players and the current state of the world. It will also introduce functions which will allow you to simplify your scripts by eliminating redundant code. After this, you should be able to do about 95\% of scripting tasks that you would normally need for a Minr map.

The Advanced Topics chapter contains some very useful features. It also covers Built-ins, some of which are necessary for interacting with or querying things in Minecraft. The rest of this chapter is about optimizing and organizing scripts, as well as best practices for readability and maintability. This chapter should also help you fill in gaps in your knowledge. You should be very competent in MSC after reading up to this point.

The Special Topics chapter will cover a variety of somewhat obscure features. Many of these are specific to Minecraft mechanics. Some are focused on general computer science topics. You don't need to read this chapter unless you want to use one of the features or you just want to be very proficient and knowledgeable about MSC.

The last chapter is a few different recipes for scripting tasks that are commonly needed in Minr maps. Reading through these may give you inspiration for solving related problems or organizing scripting projects.

With all that said, I hope this Tetorial will help you build a foundation for mastering MSC. If you have any feedback or questions related to this guide, feel free to reach out to me. Good luck!

\end{preface}

\hypersetup{linkcolor=black}
\tableofcontents
\hypersetup{linkcolor=blue}

\mainmatter
\pagestyle{plain}

\chapter{Environment}
Before we can start scripting, we need to discuss the environment. By "environment," I mean the things that scripts are embedded in, the things that scripts affect and interfaces which you will write, save, and export scripts in. This is an important topic to get through. I do not recommend skipping this chapter. However, if you are already very familiar with the Minr Test Server and Vanilla Minecraft commands, you can skip to section \ref{subsec:script-commands}.

\section{Welcome to the Test Server!}
The test server is for Green+ player only. If you are reading this and are not Green+, go beat HC and come back. The server allows you to test out things that can only be done by staff on the main server. The most common things you might want to test are scripts, world edit commands, and various Vanilla Minecraft commands. The Test Server is the quintessential scripting tool. You need to test your scripts to make sure that they are importable and work correctly. To join the Test Server, go to \href{https://forums.minr.org/pages/testserver/}{this forum page}. Familiarize yourself with the rules and follow the instructions to become whitelisted and op'ed.

\subsection{Command Syntax}

We will briefly cover commands. Some commands will be Vanilla, some will be for common plugins, and some will be for the Minr plugin. When discussing commands, you will often see syntax like:

\begin{verbatim}
/advancement (grant|revoke) <targets> only <advancement> [<criterion>]
\end{verbatim}

This syntax might seem overwhelming, but it's actually fairly straightforward. The first word in a command (which follows the \texttt{/}) is the command name. Everything that follow the command name is an argument. Arguments that aren't enclosed by brackets (often called decorators in this context) like \texttt{only} in the above example are written in the command directly. Arguments enclosed in angle brackets like \texttt{<targets>} are required arguments. When you write the command, you must subtitute this with an expression that represents that argument type. Arguments enclosed in square brackets indicate that they are optional. In this example, \texttt{[<criterion>]} is optional, but the angled brackets indicate that criterion should be substituted rather than written directly. The pipe character represents a choice. In the example, \texttt{grant|revoke} means you should either write \texttt{grant} or \texttt{revoke} for that argument of the command. The parenthesis around them are just there to indicate that they are grouped as an argument. 

This paragraph is included for completeness and isn't necessary for you to understand completely. You may see ellipses (\texttt{...}) in command syntaxes. These should mean that a full command or subcommand should replace the ellipses, but sometimes people will use ellipses to just mean "something goes here." Finally, there is also a notation that is only used for \texttt{execute} commands. It looks like \texttt{... align <axes> -> execute}. This just means that another execute command needs to be chained after the command.

There is also some nuance with argument types that you don't need to understand for now, but the most important thing to note is that arguments can contain spaces. In the command below, the argument \texttt{<location>} has type \texttt{vec3} (three numbers separated by spaces).

\begin{verbatim}
/teleport <targets> <location> <rotation>
\end{verbatim}

A valid argument of this type could be \texttt{1 2 3}. The argument \texttt{<rotation>} is basically two numbers like \texttt{30 45}. So the command could end with \texttt{1 2 3 30 45}. This can be confusing to parse, but you will get used to it as you work with commands.

One final thing to note about command syntax is that if a command contains multiple optional arguments, you cannot pick which arguments to use freely (at least for Vanilla commands). You must include all optional arguments to the left of each argument that you include. Effectively, this means that as soon as you choose not to include an optional argument when writing a command, you may not add any more arguments. A command with syntax \texttt{/a [b] [c] [d]} only has valid calls of \texttt{/a}, \texttt{/a b}, \mbox{\texttt{/a b c}}, and \texttt{/a b c d}.


\begin{thinkbox}
    \begin{enumerate}
        \item Why do we need parentheses to group argument choices? Why can't we just do the following?
        \begin{verbatim}
/advancement grant|revoke <targets> only <advancement> [<criterion>]\end{verbatim} 
        If you need a hint, consider item (c) in question 2.
        \item Try to understand the following command syntaxes. For each argument, determine whether it is required, determine whether it should be written directly or substituted, and guess what might be valid values.
        \begin{enumerate}
            \item \texttt{/kick <targets> [<reason>]}
            \item \texttt{/setblock <pos> <block> [destroy|keep|replace|strict]}
            \item \texttt{/execute rotated (<rot>|as <targets>) -> execute}
            \item \texttt{/effect give <targets> <effect> infinite [<amplifier>]} \\
            \texttt{[<hideParticles>]}
        \end{enumerate}
        \item Why don't we see Vanilla command syntaxes with required arguments to the right of optional arguments?
    \end{enumerate}
\end{thinkbox}

\subsection{Basic Commands}

At this point, you should have access to the Test Server and be somewhat comfortable reading command syntax. In this section we will introduce commands that you will need to set up a testing area and commands that are used often in scripts.

\subsubsection*{Changing Gamemodes}

The first thing you will want to do is go into creative and spectator modes. You can always use the Vanilla command \texttt{/gamemode <gamemode> [<target>]}, but it's more convenient to use the shortcuts \texttt{/creative}, \texttt{/spectator}, etc. for changing your own gamemode. Even more convenient is the \texttt{F3+F4} keyboard shortcut. Go ahead and fly somewhere away from other people's stuff and find a nice place to set up a testing area.

\subsubsection*{Building a platform}

It is usually very convenient to have a flat platform to test scripts on. The easiest way to get this platform is with WorldEdit. Simply fly to one corner of where you want the platform to be and run \texttt{//pos1}, then fly to the opposite corner and run \texttt{//pos2}, and set the selection to a block of your choosing with \texttt{//set <pattern>} where \texttt{<pattern>} can be a block of your choosing (please do not choose something with gravity like sand or water or block entities like furnaces or beehives). A $100 \times 100$ platform should be enough for a long time. This is about all the world edit we'll cover in this guide. If you want to learn more there are many resources. % maybe link some in an appendix

\subsubsection*{Defining a region}

While you have this area selected, you may as well create a region. Run \texttt{//expand vert} to make the selection cover every y level. Then do \texttt{/rg define <id> [<owners>]}, where \texttt{<id>} is the name of the region and \texttt{<owners>} are the players you wish to be the owners of the region (you should include yourself). The region will be defined based on your current WorldEdit selection. This won't be too helpful in preventing people from messing with your region since ops bypass region protection by default on the Test Server, but it is good to know how to define a region and there may be flags you want to set.

\subsubsection*{Teleporting}

One of the most useful commands in scripting is \texttt{/teleport}, which has the alias \texttt{/tp}. Teleporting the player has obviously useful applications in making maps including story telling, maze design, and de-cheesing doors. You may already be familiar with Vanilla \texttt{tp} commands. If not here are all of the valid forms:

\begin{verbatim}
/minecraft:tp <destination-entity>
/minecraft:tp <targets> <destination-entity>
/minecraft:tp <location>
/minecraft:tp <targets> <location>
/minecraft:tp <targets> <location> <rotation>
/minecraft:tp <targets> <location> facing <facing-location>
/minecraft:tp <targets> <location> facing entity <facing-entity>
[<facing-anchor>]
\end{verbatim}

You might notice that I prefixed all the \texttt{tp} command syntaxes with \texttt{minecraft:}. This specifies that the Vanilla version of the command should be used. By default \texttt{tp} will try to use the Minr-specific command whose syntaxes are listed below. The Vanilla version is a bit more powerful than Minr's. It let's you select multiple targets that don't have to be players, and you can have the player face a position or entity. \texttt{minr:tp} on the other hand let's you specify a world to tp to. The most relevant distinction between these two is that \texttt{minecraft:tp} won't show up in chat when called through a script.

\begin{verbatim}
/minr:tp <player> [<player-destination>|<position>]
/minr:tp <position> [<world>|<rotation>]
\end{verbatim}

\subsubsection*{Potion Effects}
Another important command that will be useful for scripting is \texttt{/effect}. These allow you to give and remove arbitrary potion effect to and from entities. Here are the command syntaxes:

\begin{verbatim}
/effect give <targets> <effect> [<seconds>|infinite] [<amplifier>]
[<hideParticles>]
/effect clear [<targets>] [<effect>]
\end{verbatim}

\subsubsection*{Giving Items}
Giving players items is a very useful task in scripting. Specifying the metadata of items (custom name, lore, modifiers, etc.) can be tricky, but there are tools that can help you which we will cover shortly. The complementary task of giving items is clearing them. Both command's syntaxes are shown below.

\begin{verbatim}
/give <targets> <item> [<count>]
/clear [<targets>] [<item>] [<maxCount>]
\end{verbatim}

\subsubsection*{Summoning Entities}
On occasion, you may want to summon specific entities. The syntax is show below. Again, summoning entities with specific attributes is very difficult. We will discuss tools for doing this soon. It's worth noting that whenever an entity is created it is given a UUID. You do not need to understand anything about this except that UUIDs are useful for targetting specific entities. You may be inclined to spawn entities with specific UUIDs to select them later, but you should avoid doing this as you may accidentally create entities with duplicate UUIDs which can cause problems. Instead, you should use tags, which will be covered briefly in \nameref{subsec:target-selectors}.

\begin{verbatim}
/summon <entity> [<pos>] [<nbt>]
\end{verbatim}

\subsubsection*{Killing Players and Entities}
Killing the player who is running the script is easy. Simply run \texttt{/kill}. Again, there is a Minr-specific \texttt{kill} command that is used by default. If you want to kill things other than your own player, you need to use the Vanilla version. This is something you want to be \textbf{VERY} careful about. It's generally safe if you have a specific player you want to kill, but any other entity has to be targetted with target selectors which can be extremely dangerous. If your target selector is \texttt{@e} without any additional arguments, for example, you will target every single loaded entity on the server. Combining this with the \texttt{kill} command will have devastating effects on the server. \textbf{NEVER RUN COMMANDS WITH @e or @a WITHOUT ARGUMENTS!} I will acknowledge that it is sometimes necessary to kill non-player entities or specific groups of players, so I will explain how to use target selectors in the following section. For now, note the \texttt{kill} command syntax.

\begin{verbatim}
/minecraft:kill [<targets>]
\end{verbatim}

\subsubsection*{Target Selectors} \label{subsec:target-selectors}

The simplest target selector is \texttt{@s}. This will select the entity that executed the command. If you run a command normally, this will be your player. The next simplest selector is \texttt{@p}. This will select the player nearest to the location that the command was executed at. If you run a command normally, this will be your player. The target selector \texttt{@n} selects the nearest entity. Next is \texttt{@a}. This will select all players on the server. Clearly this is dangerous on its own. Finally, there is \texttt{@e}. This will select all entities in loaded chunks on the server. This is extremely dangerous. Exercise extreme caution.

The arguments to these selectors are key to ensuring you affect only the entities that you want to affect. Arguments are written as a list of argument names and values enclosed by square brackets. The syntax can be described as follows. \texttt{variable} can be \texttt{e}, \texttt{a}, \texttt{p}, etc. Note that here the square brackets are actually typed in the expression and the ellipsis represents extending the list of argument-value pairs rather than a full command/subcommand.

\begin{verbatim}
@<variable>[<argument>=<value>,<argument>=<value>,...]
\end{verbatim}

There are many arguments, but I will cover some of the more useful ones. The most important one is \texttt{distance}. You should \textbf{ALWAYS} include a spatial argument if you are using \texttt{@e} or \texttt{@a}. \texttt{distance} is the simplest spatial argument. You will almost always use it like \texttt{distance=..10}. This limits the entities being targetted to be at most 10 blocks away (Euclidean distance). You can replace this number with whatever is appropriate for you use case. Just be careful.

Another useful argument is \texttt{type}. You can choose to only target pigs for example with \texttt{type=pig}. You can also choose to target all entities that aren't players with \texttt{type=!player}.

You can add an extra layer of safety by utilizing tags. Usually if there are things you want to kill, they are things that you have summoned earlier. If this is the case, you can give the entities a unique tag when you summon them and only select that tag when you kill it with \texttt{tag=<tagname>}.

Another layer of safety is to use the \texttt{limit} and \texttt{sort} arguments to cap the number of entities selected. This could be \texttt{limit=5,sort=nearest} to only select up to 5 entities and choose the 5 nearest entities which match the other arguments.

There are many more arguments that you can read about \href{https://minecraft.wiki/w/Target_selectors}{on the wiki}. The most important takeaway is to use something like \texttt{distance=..10} whenever you target all entities or players. If you are ever unsure about a command, ask someone who is knowledgeable or test it in a singleplayer world or in your own personal server.

\subsubsection*{Commands with Metadata}
As mentioned before, it can be challenging to write some commands, especially those which give certain attributes to items or entities. Creating such commands requires writing a complicated syntax tree inline, which is unintuitive even for experienced professional programmers. Luckily, there's a tool called \href{https://mcstacker.net/}{MCStacker.net}. This will be your best friend when writing these commands. Be mindful that there is a 256 character limit per chat message (which includes commands), so you can't run super long commands in chat. You will need to use a command block or run it in a script (we'll talk about scripts at some point I promise). Also note that commands change between Minecraft versions, and MCStacker will use the latest version by default, so you may need to select a different version.

\begin{thinkbox}
\begin{enumerate}
    \item Reflect on all the commands described in this section. How are each of these useful in the context of a Minr map? Where have you seen them used? How have they affected your experience when playing a map?
    \item Look at the last 4 versions of \texttt{minecraft:tp}. These could have been written in a single syntax description. Try and write what that would look like. Is it easier or harder to read?
    \item The value given to the \texttt{distance} argument can either be a number or a range of numbers. \texttt{distance=..10} means the distance can be at most 10, \texttt{distance=10..} means the distance can be at most 10, and \texttt{distance=10} means the distance has to be exactly 10. You can also do \texttt{distance=5..10} which means the distance is between 5 and 10. Try to visualize the regions that would be defined by these values. How are they shaped? Which ones seem more useful in the context of a Minr map?
    \item Visit \href{https://mcstacker.net/}{MCStacker.net}. Try making some give and summon commands. Below are some examples to try. You may need paste the command into a command block if it's too long.
    \begin{enumerate}
        \item A command to give yourself a Netherite Sword with a custom name, a +5 attack damage attribute, and Sharpness V enchantment.
        \item A command to summon an armor stand with an unbreakable diamond chestplate, green-dyed leather pants, chainmail boots with an armor trim, your own player head in the head slot, and arms visible.
        \item A command to summon a glowing, weak personality panda with double size.
    \end{enumerate}
    
\end{enumerate}
\end{thinkbox}

\subsection{Script Commands} \label{subsec:script-commands}

In order to test scripts, you must be able to attach them to things on the server. Everything you need will be contained within the \texttt{/script} command, which has the convenient alias of \texttt{/s}. Script commands follow the following pattern.

\begin{verbatim}
/script <action> <type> [type-parameters] [action-parameters]
\end{verbatim}

% TODO: create an action/actionaparameter table
%       create a type/typeparameter table

Script types and their corresponding parameters are summarized below. The most important script types are interact, walk, area, and entity. These will be covered in detail in section \ref{sec:triggers}. The last three will be discussed much later.

\begin{tablebox}[Script Types]
    \rowcolors{2}{rowgray}{}
    % \begin{longtable}{@{} p{2.5cm} p{1.25cm} p{\dimexpr\linewidth-5.5cm\relax} @{}}
    \begin{tabularx}{\textwidth}{@{} L{2.5cm} L{1.25cm} L{\dimexpr\linewidth-5.25cm\relax} @{} }
    \hiderowcolors
    \textbf{Type} & \textbf{Alias} & \textbf{Parameters}  \\
    \showrowcolors
    \midrule
    \endfirsthead
    \textbf{Type} & \textbf{Alias} & \textbf{Parameters}  \\
    \midrule
    \endhead
    \texttt{interact} & \texttt{i} & \texttt{[<position> <world>]}  \\ 
    \texttt{walk} & \texttt{w} & \texttt{[<position> <world>]}  \\ 
    \texttt{ground} & \texttt{g} & \texttt{[<position> <world>]}  \\ 
    \texttt{entity} & \texttt{e} & \texttt{[<uuid>]}  \\ 
    \texttt{area} & \texttt{a} & \texttt{<area>}  \\ 
    \texttt{function} & \texttt{f} & \texttt{<namespace> <function>}  \\ 
    \texttt{method} & \texttt{m} & \texttt{<namespace> <Type> <method>}  \\
    \texttt{constructor} & \texttt{c} & \texttt{<namespace> <constructor-signature>}  \\ 
    \end{tabularx}
    % \end{longtable}
\end{tablebox}

The actions and their corresponding parameters are summarized in the table below. The first five will be very important for testing scripts. The rest are included for reference.

\begin{tablebox}[Script Actions]
    \rowcolors{2}{rowgray}{}
    \begin{tabularx}{\textwidth}{@{} L{1.3cm} L{0.75cm} L{2cm} X @{}}
    \hiderowcolors
    \textbf{Action} & \textbf{Alias} & \textbf{Parameters} & \textbf{Description} \\
    \showrowcolors
    \midrule
    \endfirsthead
    \textbf{Action} & \textbf{Alias} & \textbf{Parameters} & \textbf{Description} \\
    \midrule
    \endhead
    \texttt{create} & \texttt{c} & \texttt{[line]} & Inserts a line at the specified line number. If no line number is given, appends to the end of the script. \\
    \texttt{remove} & \texttt{r}  & \texttt{[line]} & Removes a line at the specified line number. If no line number is given, removes the whole script. \\
    \texttt{view}  & \texttt{v} & & Prints the script in chat. \\
    \texttt{import} & \texttt{i} & \texttt{<id>} & Imports a script from the specified Hastebin link or identifier. See next section for more information. \\
    \texttt{export} & \texttt{e} &  & Exports a script to a Hastbin link. Useful for editing or viewing long scripts. \\
    \texttt{undo} &  &  & Undo the last create, remove, import, or export. Does not work with functions, methods, or constructors. Can store up to 10 actions. Like WorldEdit, the undo stack will not be destroyed on logout, but will be destroyed on server restart. \\
    \texttt{copy} &  & \texttt{<type>} & Copies all scripts in your WorldEdit selection of the specified type (interact, walk, or ground) to your clipboard. \\
    \texttt{paste} &  & \texttt{<type>} & Pastes the scripts from your clipboard as a specified type. The locations will be relative to the position you copied them similar to WorldEdit. \\
    \texttt{count} &  & \texttt{<type>} & Counts the number of scripts in your WorldEdit selection of the specified script type. \\
    \texttt{wipe} &  & \texttt{<type>} & Removes all scripts in your WorldEdit selection of the specified type. 
    \end{tabularx}
\end{tablebox}

\begin{thinkbox}
Practice using script commands.
\begin{enumerate}
    \item Try running \texttt{/s c i @player Hello!} and right clicking on a block. Right click it again to trigger the script.
    \item Try running \texttt{/s r i} and right clicking the same block.
    \item Try doing the same thing but by specifying the block through position and world name. (You are likely in Zero on the Test Server.)
    \item Try running \texttt{/s i i olafubemis} and right clicking a block.
    \item View the script. You may not understand it yet, but try to guess how it works.
    \item Export the script and open the link.
\end{enumerate}
\end{thinkbox}

\section{Hastebin}
\href{https://paste.minr.org}{Hastebin} has been the canonical interface to write MSC for years. It is definitely a lot easier for editing scripts than using \texttt{create} and \texttt{remove}. It is certainly not perfect, but it is a good place to start.

To use Hastebin, navigate to \href{https://paste.minr.org}{paste.minr.org} on your favorite browser. You can now type a script onto this webpage. Below is an example script you can try typing in (or just copy-paste).

\begin{msccode}{Simple Script}
@player Hello &a{{player}}&r!
@delay 1s
@player 1+2={{1+2}}
\end{msccode}

Press the "Save" button or use the keyboard shortcut \texttt{ctrl+s} to save the script and generate a unique identifier for the script. Copy the URL and import it onto a block. You can edit the script by clicking the "Duplicate \& Edit" button or use \texttt{ctrl+d}. You can make a new script with the "New" button or use \texttt{ctrl+n}. To view the script as a raw textfile (which is useful for saving it as a file) click the "Just Text" button or use \texttt{ctrl+shift+r}. That's all there is. It's a very basic text editor with minimal features. This is the editor that most MSC scripters use, and you can use this to accomplish any arbitrary scripting goal. However, trying to do anything even slightly complicated in Hastebin will quickly become irritating. You can use Hastebin for simple things like basic dialogue or teleport scripts. I recommend using Visual Studio Code for everything else.

If you are not convinced, I will list some of the downsides of using Hastebin.
\begin{enumerate}
    \item When you write a large scripting project, there will be several scripts, and it is very hard to track the links. You could put them in bookmark folders or in a spreadsheet, but it's still very inconvenient.
    \item You often want to edit multiple scripts at once. With Hastebin, you will have to memorize which browser tab contains which script. A lot of time will be wasted swapping between tabs.
    \item It's easy to accidentally close a browser tab and lose the script. You can get it back with \texttt{ctrl+shift+t} usually or through your browser menu, but it's a hassle.
    \item If you closed a tab a long time ago and you really want to recover the script, you will have to pain-stakingly look through your browser history and check each Hastebin link.
    \item There is no concept of source control. This would let you create new versions of scripts while still being able to restore previous versions. This would also make collaborating much easier.
    \item There is no syntax highlighting. Hastebin will try to guess which language your script is written in, but MSC is not a recognized language so it will just guess something wrong and highlight it based off whatever it chooses. You don't get highlighting or type checking as you write, which will help prevent syntax errors.
    \item There is no way to script offline. This isn't a big deal since you can't test scripts without being connected to the server anyways, but there are situations where this would be nice.
    \item There is currently a horrible bug in the Hastebin editor. Select a chunk of code and press tab. In code-oriented text editors, this would indent the selected lines. In Hastebin, it replaces everything with a tab character and somehow breaks the undo stack, meaning you permanently lost your code. You will only be able to restore what you saved last.
    \item There are many missing features that you would want in a text editor: find and replace, keyboard shortcuts/macros, multi-cursors, multi-line indent/unindent, autoformat, etc.
\end{enumerate}

These are issues you will eventually encounter after you get into scripting. If you start using other Visual Studio Code early on, you will save yourself from the headaches of Hastebin later on. There is a bit of overhead in setting up Visual Studio Code, which is probably why it isn't widely recommended for people new to scripting, but I think it is worth building good habits as early as possible.

\section{Visual Studio Code}
\blindtext

\section{Source Control}
\blindtext

\section{Tips}
\blindtext

\section{Summary}
\blindtext

\chapter{The Basics}

\section{Triggers} \label{sec:triggers}
\blindtext

\section{What is a Script?}
\blindtext

\section{Running Commands}
\blindtext

\section{Printing to the Player}
\blindtext

\section{Delay}
\blindtext

\section{Values and Types}
\blindtext

\section{Expressions}
\blindtext

\section{Variables}
\blindtext

\section{Summary}
\blindtext

\section{Exercises}
\blindtext

\chapter{Core Topics}
\blindtext

\section{Lists}
\blindtext

\section{Control Flow}
\blindtext

\section{Namespaces}
\blindtext

\section{Variable Qualifiers}
\blindtext

\section{Functions}
\blindtext

\section{Meta Operators}
\blindtext

\section{Summary}
\blindtext

\section{Exercises}
\blindtext

\chapter{Advanced Topics}
\blindtext

\section{User-Defined Types}
\blindtext

\section{Schematics}
\blindtext

\section{Chat Scripts}
\blindtext

\section{More about Lists and Strings}
\blindtext

\section{Built-in Namespaces}
\blindtext

\section{Built-in Types}
\blindtext

\section{Complexity}
\blindtext

\section{Best Practices}
\blindtext

\section{Learn to Learn}
\blindtext

\section{Summary}
\blindtext

\section{Exercises}
\blindtext

\chapter{Special Topics}
\blindtext

\section{Block Displays}
\blindtext

\section{Animating Entities}
\blindtext

\section{Abstraction}
\blindtext

\section{Books}
\blindtext

\section{Scoreboards}
\blindtext

\section{Boss Bars}
\blindtext

\section{Importing Scripts with Scripts}
\blindtext

\section{Execute}
\blindtext

\section{Resource Packs}
\blindtext

\section{Debug Tools}
\blindtext

\section{Recursion}
\blindtext

\section{Attributes}
\blindtext

\section{Summary}
\blindtext

\section{Exercises}
\blindtext

\chapter{Recipes}

\section{Stateful Puzzles}
\blindtext

\section{Search Maps}
\blindtext

\section{Managing Heads}
\blindtext


% \begin{msccode}
% # Long prng::uuidToSeed(String uuid, Long modulo)

% @using prng
% @player Hello? test

% @define Long seed = 0l

% @define Boolean boo3 = true

% @var myNamespace::myObj.myMethod(0, 2, 3)

% @var myNamespace::myFunction("test")

% @var seed = normalize(seed).toLowerCase().length()

% @define String hex = "0123456789abcdef"
% @define String test_string = "seed is {{seed}}"
% @define Int j = 0

% @var uuid = uuid.replace("-", "").toLowerCase()
% @define Int l = uuid.length()-9

% @for Int i in list::range(0,l)
%     @player loop iteration {{i}}
%     @var j = l-i-1
%     @var seed = (seed + hex.indexOf(uuid.substring(j, j+1)) * pow(16l, i)) % modulo
% @done

% @define Box box = Box()

% @return seed
% \end{msccode}

% \begin{nmscode}
% @namespace myNamespace
% 	# myFunc documentation
% 	Double myFunc(Player player, Item item)
% 	myVoidFunc()
% 	# myVar documentation
% 	Double myVar

% 	# myClass documentation
% 	@class MyClass
% 		# constructor
% 		MyClass(Double value)
% 		# another constructor
% 		MyClass(Double value1, Double value2)
% 		# field
% 		Double x
% 		# getter
% 		Double getX()
% 		# setter
% 		setX(Double newValue)
% 		myNamespace::MyClass getMyClass()
% 	@endclass
% @endnamespace
% \end{nmscode}

\begin{versionhistory}
    \vhEntry{0.1}{\today}{Tetration}{First Publication}
\end{versionhistory}

\end{document}
